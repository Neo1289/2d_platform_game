<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="###LIBRARIES&#10;from libraries_and_settings import (pygame,&#10;                                    sys,&#10;                                    random)&#10;###CONFIGURATIONS&#10;from libraries_and_settings import (display_surface, maps, TILE_SIZE, WINDOW_HEIGHT,WINDOW_WIDTH,&#10;                                    font,enemies_images,enemies_speed,enemies_direction,spawning_time,key_dict,player_flame_frames,enemies_life)&#10;from words_library import phrases,instructions&#10;&#10;###SPRITES&#10;from player import Player&#10;from camera import allSpritesOffset&#10;from sprites import GeneralSprite,AreaSprite,NPC,Rune,Fire&#10;&#10;pygame.init()&#10;&#10;class Game:&#10;    def __init__(self):&#10;&#10;        self.running = True&#10;        self.display_surface = display_surface&#10;        self.clock = pygame.time.Clock()&#10;        self.start_time = 0&#10;        self.duration_time = 0&#10;        self.temporary_action = None&#10;        self.key_dict = key_dict&#10;        self.last_time_guard = 0&#10;&#10;        self.maps = maps&#10;        self.current_map = None&#10;        self.current_area = &quot;world&quot;&#10;        self.area_group = {}&#10;        self.transition_bool = True&#10;        self.phrases = phrases&#10;        self.enemies_images = enemies_images&#10;        self.enemies_direction = enemies_direction&#10;        self.enemies_list = list(self.enemies_images.keys())&#10;        self.enemies_life = enemies_life&#10;&#10;        self.collision_sprites = pygame.sprite.Group()&#10;        self.all_sprites = allSpritesOffset()&#10;        self.player = None&#10;&#10;        self.spawning_time = spawning_time&#10;&#10;        self.game_objects = ['potion','crystal ball','coin','runes dust','nothing useful','holy water','fire dust']&#10;        self.weights = [0.4,0.1,0.49,0.01,1,0.00001,0.3]&#10;        self.last_item = ''&#10;&#10;        self.custom_event = pygame.event.custom_type()&#10;&#10;        # Introduction screen flag&#10;        self.show_intro = True&#10;        self.instructions = instructions&#10;&#10;    def show_introduction_screen(self):&#10;        self.display_surface.fill('black')&#10;&#10;        instruction_y = 160&#10;        instruction_font = font&#10;        for line in self.instructions:&#10;            text_surf = instruction_font.render(line, True, &quot;white&quot;)&#10;            text_rect = text_surf.get_rect(midleft=(WINDOW_WIDTH // 4, instruction_y))&#10;            self.display_surface.blit(text_surf, text_rect)&#10;            instruction_y += 30&#10;&#10;        pygame.display.update()&#10;&#10;        waiting = True&#10;        while waiting:&#10;            self.clock.tick(60)&#10;            for event in pygame.event.get():&#10;                if event.type == pygame.QUIT:&#10;                    pygame.quit()&#10;                    sys.exit()&#10;                if event.type == pygame.KEYDOWN:&#10;                    if event.key == pygame.K_SPACE:&#10;                        waiting = False&#10;                    elif event.key == pygame.K_ESCAPE:&#10;                        pygame.quit()&#10;                        sys.exit()&#10;&#10;    def mapping(self):&#10;&#10;        self.all_sprites.empty()&#10;        self.collision_sprites.empty()&#10;        self.area_group.clear()&#10;&#10;        for name, map in self.maps.items():&#10;            if name == self.current_area:&#10;                self.current_map = map&#10;        ###ground&#10;        for x, y, image in self.current_map.get_layer_by_name('ground').tiles():&#10;            GeneralSprite((x * TILE_SIZE, y * TILE_SIZE), image, self.all_sprites,True)&#10;        ###objects&#10;        for obj in self.current_map.get_layer_by_name('objects'):&#10;            GeneralSprite((obj.x, obj.y), obj.image, (self.all_sprites,self.collision_sprites),None,obj.name,1,item= True)&#10;        ###player&#10;        for obj in self.current_map.get_layer_by_name('areas'):&#10;            if obj.name == 'player_spawn':&#10;                if self.player is None:&#10;                    self.player = Player((obj.x, obj.y), self.all_sprites, self.collision_sprites)&#10;                else:&#10;                    self.player.collision_rect.center = (obj.x, obj.y)&#10;                    self.all_sprites.add(self.player)&#10;&#10;            elif obj.name not in self.enemies_list:&#10;                self.area_group[obj.name] = AreaSprite(obj.x, obj.y, obj.width, obj.height, self.all_sprites,obj.name)&#10;            else:&#10;                self.monsters()&#10;&#10;    def monsters(self):&#10;        for obj in self.current_map.get_layer_by_name('areas'):&#10;            if obj.name in  self.enemies_list:&#10;                self.monster = NPC((obj.x, obj.y), self.enemies_images[obj.name], self.all_sprites, obj.name,&#10;                                   enemies_speed[obj.name], True,self.enemies_life[obj.name], self.enemies_direction[obj.name],&#10;                                   follow_player=obj.name in ['scheleton', 'dragon','bat_1'])&#10;                self.monster.player = self.player&#10;&#10;    def enter_area_check(self,event):&#10;        for name, area in self.area_group.items():&#10;        ###check if the player pressed yes key to enter the area&#10;            if area.rect.colliderect(self.player.rect) and self.key_down(event,&quot;y&quot;):&#10;                self.transition_bool = True&#10;        ###perform the actual transition between areas&#10;        if self.transition_bool:&#10;            self.mapping()&#10;            self.transition_bool = False&#10;&#10;            pygame.time.set_timer(self.custom_event, self.spawning_time[self.current_area])&#10;&#10;    def rendering(self):&#10;        self.text_surface = None&#10;        ###determine the current area map to be loaded and print it&#10;        for name, area in self.area_group.items():&#10;            if area.rect.colliderect(self.player.rect):&#10;                    if name not in ('danger area','recall'):&#10;                        self.current_area = name&#10;                        self.text = f&quot;You found a {name} press Y to enter&quot;&#10;                        self.text_surface = font.render(self.text,True,&quot;white&quot;)&#10;&#10;        for obj in self.collision_sprites:&#10;            if self.object_id(obj):&#10;               self.text = f&quot;{self.phrases[&quot;text_2&quot;]}{obj.name}?&quot;&#10;               self.text_surface = font.render(self.text, True, &quot;white&quot;)&#10;            elif self.human_id(obj):&#10;                self.text = f&quot;{self.phrases[&quot;text_1&quot;]}&quot;&#10;                self.text_surface = font.render(self.text, True, &quot;white&quot;)&#10;&#10;        if self.text_surface:&#10;            text_rect = self.text_surface.get_rect(center=(WINDOW_WIDTH // 3, WINDOW_HEIGHT // 4))&#10;            self.display_surface.blit(self.text_surface, text_rect)&#10;&#10;    def collect_resources(self,event):&#10;        for obj in self.collision_sprites:&#10;            if self.object_id(obj):&#10;                if self.key_down(event, &quot;y&quot;):&#10;                    if hasattr(obj,'rune'):&#10;                        self.player.inventory['runes dust']+= 1&#10;                        obj.kill()&#10;                        self.last_item = 'runes dust'&#10;                    else:&#10;                        choice = random.choices(self.game_objects,weights=self.weights,k=1)[0]&#10;                        self.player.inventory[choice]+= 1&#10;                        self.last_item = choice&#10;                    obj.resources -= 1&#10;&#10;    def event_timer(self):&#10;        self.time_event = (pygame.time.get_ticks() - self.start_time) // 1000&#10;&#10;        if self.preventing_repetition() and self.player.inventory['fire dust'] &lt; 50:&#10;            self.player.inventory['fire dust'] += 1&#10;            self.last_time_guard = self.time_event&#10;&#10;    def reset_timer(self, event):&#10;        for key,value in self.key_dict.items():&#10;            #####value[time,action name,effect]&#10;            if self.key_down(event, key) and self.player.inventory[value[1]] &gt; 0:&#10;                self.start_time = pygame.time.get_ticks()&#10;                self.duration_time = value[0]&#10;                self.player.inventory[value[1]] -= 1&#10;                self.temporary_action = value[1]&#10;                self.effect = value[2]&#10;&#10;    def player_buffers(self):&#10;        enemies = self.enemies_groups()&#10;        for obj in self.game_objects:&#10;            if self.duration_time &gt;= self.time_event and self.temporary_action == obj:&#10;                self.player.life += self.effect&#10;                if self.temporary_action == 'runes dust':&#10;                    position = (random.choice([100, -100, 50, -50, 200, -200, 0]) + self.player.rect.x,&#10;                                        random.choice([100, -100, 50, -50, 200, -200, 0]) + self.player.rect.y)&#10;                    Rune(position, self.all_sprites)&#10;                if self.temporary_action == 'crystal ball':&#10;                    for enemy in enemies:&#10;                        enemy.speed = 0&#10;&#10;    def player_fire(self,event):&#10;        if self.key_down(event,'z') and self.player.inventory['fire dust'] &gt; 0:&#10;            Fire(self.player.rect.center,player_flame_frames,self.all_sprites,10,self.player.state)&#10;            self.player.inventory['fire dust'] -= 1&#10;&#10;&#10;    def trading(self,event):&#10;        for obj in self.collision_sprites:&#10;            if self.human_id(obj):&#10;                if self.key_down(event,&quot;s&quot;) and self.player.inventory[&quot;crystal ball&quot;] &gt; 0:&#10;                    self.player.inventory[&quot;crystal ball&quot;] -= 1&#10;                    self.player.inventory[&quot;coin&quot;] += 3&#10;                if self.key_down(event, &quot;b&quot;) and self.inventory[&quot;coin&quot;] &gt;= 0:&#10;                    self.player.inventory[&quot;coin&quot;] -= 1&#10;                    self.player.inventory[&quot;potion&quot;] += 1&#10;                if self.key_down(event, &quot;n&quot;) and self.inventory[&quot;coin&quot;] &gt;= 5:&#10;                    self.player.inventory[&quot;coin&quot;] -= 3&#10;                    self.player.inventory[&quot;holy water&quot;] += 1&#10;&#10;    def collision_detection(self):&#10;        for obj in self.all_sprites:&#10;            if obj.rect.colliderect(self.player.rect):&#10;                if hasattr(obj, &quot;dangerous&quot;): self.player.life -= 1&#10;&#10;        if self.player.life &lt;= 0:&#10;            self.caption = pygame.display.set_caption('GAME OVER')&#10;            pygame.time.delay(5000)&#10;            pygame.quit()&#10;            sys.exit()&#10;&#10;    def check_enemies_collision(self):&#10;        enemies = self.enemies_groups()&#10;        projectiles = pygame.sprite.Group([&#10;            sprite for sprite in self.all_sprites&#10;            if isinstance(sprite, (Rune, Fire))&#10;        ])&#10;&#10;        for enemy in enemies:&#10;            if pygame.sprite.spritecollideany(enemy, projectiles):&#10;                enemy.life -= 1&#10;            if enemy.life == 0:&#10;                enemy.kill()&#10;&#10;    def display_captions(self):&#10;        time_sec = pygame.time.get_ticks() // 1000&#10;        self.caption = (f&quot;\u2665 {self.player.life}     &quot;&#10;                        f&quot;\U0001F9EA {self.player.inventory['potion']}     &quot;&#10;                        f&quot;\U0001F52E {self.player.inventory['crystal ball']}     &quot;&#10;                        f&quot;\U0001F4B0 {self.player.inventory['coin']}     &quot;&#10;                        f&quot;\U0001F5DD {self.player.inventory['keys']}     &quot;&#10;                        f&quot;\u2697\ufe0f {self.player.inventory['holy water']}     &quot;&#10;                        f&quot;\U0001F4AB {self.player.inventory['runes dust']}     &quot;&#10;                        f&quot;\U0001F525{self.player.inventory['fire dust']}     &quot;&#10;                        &#10;                        f&quot;timer: {time_sec}          &quot;&#10;                        f&quot;last item found: {self.last_item}     &quot;&#10;                        )&#10;        pygame.display.set_caption(self.caption)&#10;&#10;    ################################&#10;    ####REDUNDANT CODE REDUCTION####&#10;    ################################&#10;    def object_id(self,obj):&#10;        if obj.rect.colliderect(self.player.rect) and hasattr(obj, &quot;name&quot;) and hasattr(obj,&#10;                                                                                           &quot;item&quot;) and not hasattr(obj,&#10;                                                                                           &quot;human&quot;)  and obj.resources &gt; 0:&#10;            return True&#10;&#10;    def human_id(self,obj):&#10;        if obj.rect.colliderect(self.player.rect) and hasattr(obj, &quot;human&quot;):&#10;            return True&#10;&#10;    def key_down(self, event, key: str):&#10;        if event.type == pygame.KEYDOWN:&#10;            self.key_event = pygame.key.name(event.key)&#10;        return event.type == pygame.KEYDOWN and event.key == getattr(pygame, f&quot;K_{key}&quot;)&#10;&#10;    def enemies_groups(self):&#10;        return [sprite for sprite in self.all_sprites if isinstance(sprite, NPC)]&#10;&#10;    def preventing_repetition(self):&#10;        return  self.time_event % 10 == 0 and self.time_event != self.last_time_guard&#10;&#10;    def run(self):&#10;        # Show introduction screen before starting the game&#10;        if self.show_intro:&#10;            self.show_introduction_screen()&#10;            self.show_intro = False&#10;            self.mapping()&#10;&#10;        while self.running:&#10;            dt = self.clock.tick(60) / 1000&#10;&#10;            for event in pygame.event.get():&#10;                if event.type == pygame.QUIT:&#10;                    self.running = False&#10;                    sys.exit()&#10;                self.enter_area_check(event)&#10;                self.collect_resources(event)&#10;                self.trading(event)&#10;                self.reset_timer(event)&#10;                self.player_fire(event)&#10;                if event.type == self.custom_event:&#10;                    self.monsters()&#10;&#10;            self.event_timer()&#10;            self.display_surface.fill('black')&#10;            self.all_sprites.update(dt)&#10;            self.all_sprites.draw(self.player.rect.center)&#10;            self.rendering()&#10;            self.display_captions()&#10;            self.collision_detection()&#10;            self.check_enemies_collision()&#10;            self.player_buffers()&#10;&#10;            pygame.display.update()&#10;&#10;        pygame.quit()&#10;&#10;if __name__ == '__main__':&#10;    main_game = Game()&#10;    main_game.run()" />
              <option name="updatedContent" value="###LIBRARIES&#10;from libraries_and_settings import (pygame,&#10;                                    sys,&#10;                                    random)&#10;###CONFIGURATIONS&#10;from libraries_and_settings import (display_surface, maps, TILE_SIZE, WINDOW_HEIGHT,WINDOW_WIDTH,&#10;                                    font,enemies_images,enemies_speed,enemies_direction,spawning_time,key_dict,player_flame_frames,enemies_life)&#10;from words_library import phrases,instructions&#10;&#10;###SPRITES&#10;from player import Player&#10;from camera import allSpritesOffset&#10;from sprites import GeneralSprite,AreaSprite,NPC,Rune,Fire&#10;&#10;pygame.init()&#10;&#10;class Game:&#10;    def __init__(self):&#10;&#10;        self.running = True&#10;        self.display_surface = display_surface&#10;        self.clock = pygame.time.Clock()&#10;        self.start_time = 0&#10;        self.duration_time = 0&#10;        self.temporary_action = None&#10;        self.key_dict = key_dict&#10;        self.last_time_guard = 0&#10;&#10;        self.maps = maps&#10;        self.current_map = None&#10;        self.current_area = &quot;world&quot;&#10;        self.area_group = {}&#10;        self.transition_bool = True&#10;        self.phrases = phrases&#10;        self.enemies_images = enemies_images&#10;        self.enemies_direction = enemies_direction&#10;        self.enemies_list = list(self.enemies_images.keys())&#10;        self.enemies_life = enemies_life&#10;&#10;        self.collision_sprites = pygame.sprite.Group()&#10;        self.all_sprites = allSpritesOffset()&#10;        self.player = None&#10;&#10;        self.spawning_time = spawning_time&#10;&#10;        self.game_objects = ['potion','crystal ball','coin','runes dust','nothing useful','holy water','fire dust']&#10;        self.weights = [0.4,0.1,0.49,0.01,1,0.00001,0.3]&#10;        self.last_item = ''&#10;&#10;        self.custom_event = pygame.event.custom_type()&#10;&#10;        # Game state management&#10;        self.game_state = &quot;intro&quot;  # Can be &quot;intro&quot; or &quot;gameplay&quot;&#10;        self.instructions = instructions&#10;&#10;    def show_introduction_screen(self):&#10;        self.display_surface.fill('black')&#10;&#10;        # Add title&#10;        title_font = pygame.font.Font(None, 60)&#10;        title_surf = title_font.render(&quot;Game Instructions&quot;, True, &quot;white&quot;)&#10;        title_rect = title_surf.get_rect(center=(WINDOW_WIDTH // 2, 80))&#10;        self.display_surface.blit(title_surf, title_rect)&#10;        &#10;        # Show instructions&#10;        instruction_y = 160&#10;        instruction_font = font&#10;        for line in self.instructions:&#10;            text_surf = instruction_font.render(line, True, &quot;white&quot;)&#10;            text_rect = text_surf.get_rect(midleft=(WINDOW_WIDTH // 4, instruction_y))&#10;            self.display_surface.blit(text_surf, text_rect)&#10;            instruction_y += 30&#10;        &#10;        # Show navigation instructions at the bottom&#10;        help_text = &quot;Press SPACE to play game | Press H anytime during gameplay to return to this screen&quot;&#10;        help_surf = instruction_font.render(help_text, True, (255, 255, 100))&#10;        help_rect = help_surf.get_rect(center=(WINDOW_WIDTH // 2, WINDOW_HEIGHT - 50))&#10;        self.display_surface.blit(help_surf, help_rect)&#10;&#10;        pygame.display.update()&#10;&#10;        # Wait for player to press space to continue&#10;        waiting = True&#10;        while waiting and self.running:&#10;            self.clock.tick(60)&#10;            for event in pygame.event.get():&#10;                if event.type == pygame.QUIT:&#10;                    self.running = False&#10;                    pygame.quit()&#10;                    sys.exit()&#10;                if event.type == pygame.KEYDOWN:&#10;                    if event.key == pygame.K_SPACE:&#10;                        self.game_state = &quot;gameplay&quot;&#10;                        waiting = False&#10;                    elif event.key == pygame.K_ESCAPE:&#10;                        self.running = False&#10;                        pygame.quit()&#10;                        sys.exit()&#10;&#10;    def mapping(self):&#10;&#10;        self.all_sprites.empty()&#10;        self.collision_sprites.empty()&#10;        self.area_group.clear()&#10;&#10;        for name, map in self.maps.items():&#10;            if name == self.current_area:&#10;                self.current_map = map&#10;        ###ground&#10;        for x, y, image in self.current_map.get_layer_by_name('ground').tiles():&#10;            GeneralSprite((x * TILE_SIZE, y * TILE_SIZE), image, self.all_sprites,True)&#10;        ###objects&#10;        for obj in self.current_map.get_layer_by_name('objects'):&#10;            GeneralSprite((obj.x, obj.y), obj.image, (self.all_sprites,self.collision_sprites),None,obj.name,1,item= True)&#10;        ###player&#10;        for obj in self.current_map.get_layer_by_name('areas'):&#10;            if obj.name == 'player_spawn':&#10;                if self.player is None:&#10;                    self.player = Player((obj.x, obj.y), self.all_sprites, self.collision_sprites)&#10;                else:&#10;                    self.player.collision_rect.center = (obj.x, obj.y)&#10;                    self.all_sprites.add(self.player)&#10;&#10;            elif obj.name not in self.enemies_list:&#10;                self.area_group[obj.name] = AreaSprite(obj.x, obj.y, obj.width, obj.height, self.all_sprites,obj.name)&#10;            else:&#10;                self.monsters()&#10;&#10;    def monsters(self):&#10;        for obj in self.current_map.get_layer_by_name('areas'):&#10;            if obj.name in  self.enemies_list:&#10;                self.monster = NPC((obj.x, obj.y), self.enemies_images[obj.name], self.all_sprites, obj.name,&#10;                                   enemies_speed[obj.name], True,self.enemies_life[obj.name], self.enemies_direction[obj.name],&#10;                                   follow_player=obj.name in ['scheleton', 'dragon','bat_1'])&#10;                self.monster.player = self.player&#10;&#10;    def enter_area_check(self,event):&#10;        for name, area in self.area_group.items():&#10;        ###check if the player pressed yes key to enter the area&#10;            if area.rect.colliderect(self.player.rect) and self.key_down(event,&quot;y&quot;):&#10;                self.transition_bool = True&#10;        ###perform the actual transition between areas&#10;        if self.transition_bool:&#10;            self.mapping()&#10;            self.transition_bool = False&#10;&#10;            pygame.time.set_timer(self.custom_event, self.spawning_time[self.current_area])&#10;&#10;    def rendering(self):&#10;        self.text_surface = None&#10;        ###determine the current area map to be loaded and print it&#10;        for name, area in self.area_group.items():&#10;            if area.rect.colliderect(self.player.rect):&#10;                    if name not in ('danger area','recall'):&#10;                        self.current_area = name&#10;                        self.text = f&quot;You found a {name} press Y to enter&quot;&#10;                        self.text_surface = font.render(self.text,True,&quot;white&quot;)&#10;&#10;        for obj in self.collision_sprites:&#10;            if self.object_id(obj):&#10;               self.text = f&quot;{self.phrases[&quot;text_2&quot;]}{obj.name}?&quot;&#10;               self.text_surface = font.render(self.text, True, &quot;white&quot;)&#10;            elif self.human_id(obj):&#10;                self.text = f&quot;{self.phrases[&quot;text_1&quot;]}&quot;&#10;                self.text_surface = font.render(self.text, True, &quot;white&quot;)&#10;&#10;        if self.text_surface:&#10;            text_rect = self.text_surface.get_rect(center=(WINDOW_WIDTH // 3, WINDOW_HEIGHT // 4))&#10;            self.display_surface.blit(self.text_surface, text_rect)&#10;&#10;    def collect_resources(self,event):&#10;        for obj in self.collision_sprites:&#10;            if self.object_id(obj):&#10;                if self.key_down(event, &quot;y&quot;):&#10;                    if hasattr(obj,'rune'):&#10;                        self.player.inventory['runes dust']+= 1&#10;                        obj.kill()&#10;                        self.last_item = 'runes dust'&#10;                    else:&#10;                        choice = random.choices(self.game_objects,weights=self.weights,k=1)[0]&#10;                        self.player.inventory[choice]+= 1&#10;                        self.last_item = choice&#10;                    obj.resources -= 1&#10;&#10;    def event_timer(self):&#10;        self.time_event = (pygame.time.get_ticks() - self.start_time) // 1000&#10;&#10;        if self.preventing_repetition() and self.player.inventory['fire dust'] &lt; 50:&#10;            self.player.inventory['fire dust'] += 1&#10;            self.last_time_guard = self.time_event&#10;&#10;    def reset_timer(self, event):&#10;        for key,value in self.key_dict.items():&#10;            #####value[time,action name,effect]&#10;            if self.key_down(event, key) and self.player.inventory[value[1]] &gt; 0:&#10;                self.start_time = pygame.time.get_ticks()&#10;                self.duration_time = value[0]&#10;                self.player.inventory[value[1]] -= 1&#10;                self.temporary_action = value[1]&#10;                self.effect = value[2]&#10;&#10;    def player_buffers(self):&#10;        enemies = self.enemies_groups()&#10;        for obj in self.game_objects:&#10;            if self.duration_time &gt;= self.time_event and self.temporary_action == obj:&#10;                self.player.life += self.effect&#10;                if self.temporary_action == 'runes dust':&#10;                    position = (random.choice([100, -100, 50, -50, 200, -200, 0]) + self.player.rect.x,&#10;                                        random.choice([100, -100, 50, -50, 200, -200, 0]) + self.player.rect.y)&#10;                    Rune(position, self.all_sprites)&#10;                if self.temporary_action == 'crystal ball':&#10;                    for enemy in enemies:&#10;                        enemy.speed = 0&#10;&#10;    def player_fire(self,event):&#10;        if self.key_down(event,'z') and self.player.inventory['fire dust'] &gt; 0:&#10;            Fire(self.player.rect.center,player_flame_frames,self.all_sprites,10,self.player.state)&#10;            self.player.inventory['fire dust'] -= 1&#10;&#10;&#10;    def trading(self,event):&#10;        for obj in self.collision_sprites:&#10;            if self.human_id(obj):&#10;                if self.key_down(event,&quot;s&quot;) and self.player.inventory[&quot;crystal ball&quot;] &gt; 0:&#10;                    self.player.inventory[&quot;crystal ball&quot;] -= 1&#10;                    self.player.inventory[&quot;coin&quot;] += 3&#10;                if self.key_down(event, &quot;b&quot;) and self.inventory[&quot;coin&quot;] &gt;= 0:&#10;                    self.player.inventory[&quot;coin&quot;] -= 1&#10;                    self.player.inventory[&quot;potion&quot;] += 1&#10;                if self.key_down(event, &quot;n&quot;) and self.inventory[&quot;coin&quot;] &gt;= 5:&#10;                    self.player.inventory[&quot;coin&quot;] -= 3&#10;                    self.player.inventory[&quot;holy water&quot;] += 1&#10;&#10;    def collision_detection(self):&#10;        for obj in self.all_sprites:&#10;            if obj.rect.colliderect(self.player.rect):&#10;                if hasattr(obj, &quot;dangerous&quot;): self.player.life -= 1&#10;&#10;        if self.player.life &lt;= 0:&#10;            self.caption = pygame.display.set_caption('GAME OVER')&#10;            pygame.time.delay(5000)&#10;            pygame.quit()&#10;            sys.exit()&#10;&#10;    def check_enemies_collision(self):&#10;        enemies = self.enemies_groups()&#10;        projectiles = pygame.sprite.Group([&#10;            sprite for sprite in self.all_sprites&#10;            if isinstance(sprite, (Rune, Fire))&#10;        ])&#10;&#10;        for enemy in enemies:&#10;            if pygame.sprite.spritecollideany(enemy, projectiles):&#10;                enemy.life -= 1&#10;            if enemy.life == 0:&#10;                enemy.kill()&#10;&#10;    def display_captions(self):&#10;        time_sec = pygame.time.get_ticks() // 1000&#10;        self.caption = (f&quot;\u2665 {self.player.life}     &quot;&#10;                        f&quot;\U0001F9EA {self.player.inventory['potion']}     &quot;&#10;                        f&quot;\U0001F52E {self.player.inventory['crystal ball']}     &quot;&#10;                        f&quot;\U0001F4B0 {self.player.inventory['coin']}     &quot;&#10;                        f&quot;\U0001F5DD {self.player.inventory['keys']}     &quot;&#10;                        f&quot;\u2697\ufe0f {self.player.inventory['holy water']}     &quot;&#10;                        f&quot;\U0001F4AB {self.player.inventory['runes dust']}     &quot;&#10;                        f&quot;\U0001F525{self.player.inventory['fire dust']}     &quot;&#10;                        &#10;                        f&quot;timer: {time_sec}          &quot;&#10;                        f&quot;last item found: {self.last_item}     &quot;&#10;                        )&#10;        pygame.display.set_caption(self.caption)&#10;&#10;    ################################&#10;    ####REDUNDANT CODE REDUCTION####&#10;    ################################&#10;    def object_id(self,obj):&#10;        if obj.rect.colliderect(self.player.rect) and hasattr(obj, &quot;name&quot;) and hasattr(obj,&#10;                                                                                           &quot;item&quot;) and not hasattr(obj,&#10;                                                                                           &quot;human&quot;)  and obj.resources &gt; 0:&#10;            return True&#10;&#10;    def human_id(self,obj):&#10;        if obj.rect.colliderect(self.player.rect) and hasattr(obj, &quot;human&quot;):&#10;            return True&#10;&#10;    def key_down(self, event, key: str):&#10;        if event.type == pygame.KEYDOWN:&#10;            self.key_event = pygame.key.name(event.key)&#10;        return event.type == pygame.KEYDOWN and event.key == getattr(pygame, f&quot;K_{key}&quot;)&#10;&#10;    def enemies_groups(self):&#10;        return [sprite for sprite in self.all_sprites if isinstance(sprite, NPC)]&#10;&#10;    def preventing_repetition(self):&#10;        return  self.time_event % 10 == 0 and self.time_event != self.last_time_guard&#10;&#10;    def handle_events(self):&#10;        for event in pygame.event.get():&#10;            if event.type == pygame.QUIT:&#10;                self.running = False&#10;                sys.exit()&#10;                &#10;            # Check for H key to show introduction screen from gameplay&#10;            if event.type == pygame.KEYDOWN and event.key == pygame.K_h and self.game_state == &quot;gameplay&quot;:&#10;                self.game_state = &quot;intro&quot;&#10;                return True  # Signal that we're changing state&#10;                &#10;            # Process gameplay events only when in gameplay state&#10;            if self.game_state == &quot;gameplay&quot;:&#10;                self.enter_area_check(event)&#10;                self.collect_resources(event)&#10;                self.trading(event)&#10;                self.reset_timer(event)&#10;                self.player_fire(event)&#10;                if event.type == self.custom_event:&#10;                    self.monsters()&#10;                    &#10;        return False  # No state change&#10;&#10;    def run(self):&#10;        # Initialize the game map if not initialized yet&#10;        if not self.current_map:&#10;            self.mapping()&#10;            pygame.time.set_timer(self.custom_event, self.spawning_time[self.current_area])&#10;&#10;        while self.running:&#10;            dt = self.clock.tick(60) / 1000&#10;&#10;            # Handle different game states&#10;            if self.game_state == &quot;intro&quot;:&#10;                self.show_introduction_screen()&#10;            elif self.game_state == &quot;gameplay&quot;:&#10;                # Process events first to check for state changes&#10;                state_changed = self.handle_events()&#10;                if state_changed:&#10;                    continue  # Skip the rest of the loop if state changed&#10;&#10;                # Regular gameplay update&#10;                self.event_timer()&#10;                self.display_surface.fill('black')&#10;                self.all_sprites.update(dt)&#10;                self.all_sprites.draw(self.player.rect.center)&#10;                self.rendering()&#10;                self.display_captions()&#10;                self.collision_detection()&#10;                self.check_enemies_collision()&#10;                self.player_buffers()&#10;&#10;                pygame.display.update()&#10;&#10;        pygame.quit()&#10;&#10;if __name__ == '__main__':&#10;    main_game = Game()&#10;    main_game.run()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>